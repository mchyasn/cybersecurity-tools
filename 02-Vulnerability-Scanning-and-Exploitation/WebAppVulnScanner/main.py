#!/usr/bin/env python3
"""
WebAppVulnScanner – Custom Web Application Vulnerability Scanner
"""

import argparse
import json
import logging
import os
import re
import sys
from urllib.parse import urlencode

import requests

# Logging setup
LOG_FILE = "logs/debug.log"
os.makedirs("logs", exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, mode="w"),
        logging.StreamHandler(sys.stdout)
    ]
)

# Load payloads from config
def load_payloads(path):
    if not os.path.isfile(path):
        logging.error(f"Payload config not found: {path}")
        sys.exit(1)
    with open(path, "r") as f:
        return json.load(f)

# Send GET request with payload
def send_get(url, param, payload):
    injected_url = f"{url}?{urlencode({param: payload})}"
    logging.info(f"GET {injected_url}")
    try:
        response = requests.get(injected_url, timeout=5)
        log_response(response)
        return response.text
    except Exception as e:
        logging.error(f"GET request failed: {e}")
        return ""

# Send POST request with payload
def send_post(url, param, payload):
    data = {param: payload}
    logging.info(f"POST {url} with {data}")
    try:
        response = requests.post(url, data=data, timeout=5)
        log_response(response)
        return response.text
    except Exception as e:
        logging.error(f"POST request failed: {e}")
        return ""

# Log response details
def log_response(response):
    logging.debug(f"Status: {response.status_code}")
    logging.debug(f"Body: {response.text}")

# Scan target for vulnerabilities
def scan_target(url, method, param, payloads):
    results = []
    for vuln_type, payload_list in payloads.items():
        for payload in payload_list:
            if method == "GET":
                body = send_get(url, param, payload)
            else:
                body = send_post(url, param, payload)

            if detect_vulnerability(vuln_type, payload, body):
                logging.info(f"Potential {vuln_type} detected with payload: {payload}")
                results.append({
                    "url": url,
                    "method": method,
                    "param": param,
                    "vulnerability": vuln_type,
                    "payload": payload,
                    "evidence": payload
                })
    return results

# Simple pattern match detection
def detect_vulnerability(vuln_type, payload, body):
    if vuln_type in ["XSS", "SQLi"]:
        pattern = re.escape(payload)
        return re.search(pattern, body, re.IGNORECASE)
    elif vuln_type == "LFI":
        return "root:" in body or "[extensions]" in body
    elif vuln_type == "SSRF":
        return "127.0.0.1" in body or "localhost" in body
    return False

def main():
    parser = argparse.ArgumentParser(
        description="WebAppVulnScanner – Custom Web Application Vulnerability Scanner"
    )
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    parser.add_argument("-m", "--method", choices=["GET", "POST"], default="GET", help="HTTP method")
    parser.add_argument("-p", "--param", required=True, help="Parameter to inject")
    parser.add_argument("-c", "--config", default="configs/payloads.json", help="Payload config file")
    parser.add_argument("-o", "--output", default="scans/results.json", help="JSON output file")
    args = parser.parse_args()

    payloads = load_payloads(args.config)
    results = scan_target(args.url, args.method, args.param, payloads)

    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    with open(args.output, "w") as f:
        json.dump({"results": results}, f, indent=2)

    logging.info(f"Scan complete. Results saved to {args.output}")

if __name__ == "__main__":
    main()
