#!/usr/bin/env python3
"""
Custom-CVE-Exploiter – Modular CVE PoC Launcher
"""

import argparse
import importlib.util
import json
import logging
import os
import sys
from pathlib import Path
import yaml

LOG_FILE = "exploiter.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler(LOG_FILE, mode="w")
    ]
)

def check_config_file(path):
    if not os.path.isfile(path):
        logging.error(f"Config file does not exist: {path}")
        sys.exit(1)
    try:
        with open(path, "r") as f:
            return yaml.safe_load(f)
    except yaml.YAMLError as e:
        logging.error(f"Invalid YAML format in config: {e}")
        sys.exit(1)

def load_module(module_name):
    try:
        module_path = Path(__file__).parent / "modules" / f"{module_name}.py"
        if not module_path.is_file():
            logging.error(f"Module file does not exist: {module_path}")
            return None
        spec = importlib.util.spec_from_file_location(module_name, str(module_path))
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module
    except Exception as e:
        logging.error(f"Failed to load module '{module_name}': {e}")
        return None

def run_module(module, target, params):
    if not hasattr(module, "run"):
        logging.error(f"Module '{module.__name__}' missing required run()")
        return {"module": module.__name__, "target": target, "error": "Missing run()"}
    try:
        result = module.run(target, params)
        return {"module": module.__name__, "target": target, "result": result}
    except Exception as e:
        logging.exception(f"Error running module '{module.__name__}'")
        return {"module": module.__name__, "target": target, "error": str(e)}

def main():
    parser = argparse.ArgumentParser(
        description="Custom-CVE-Exploiter – launch modular CVE PoCs against targets"
    )
    parser.add_argument(
        "-c", "--config",
        default="configs/config.yaml",
        help="Path to YAML config with targets and modules"
    )
    parser.add_argument(
        "-o", "--output",
        help="Path to write JSON results (default: stdout)"
    )
    args = parser.parse_args()

    config = check_config_file(args.config)
    targets = config.get("targets")
    modules = config.get("modules")

    if not targets or not modules:
        logging.error("Config must define 'targets' and 'modules'.")
        sys.exit(1)

    results = []
    for target in targets:
        for module_def in modules:
            mod_name = module_def.get("name")
            params = module_def.get("params", {})
            logging.info(f"Target: {target} | Module: {mod_name} | Params: {params}")

            mod = load_module(mod_name)
            if mod is None:
                results.append({
                    "module": mod_name,
                    "target": target,
                    "error": "Module load failed"
                })
                continue

            res = run_module(mod, target, params)
            results.append(res)

    final_output = {"results": results}
    if args.output:
        Path(args.output).parent.mkdir(parents=True, exist_ok=True)
        with open(args.output, "w") as f:
            json.dump(final_output, f, indent=2)
        logging.info(f"Results written to {args.output}")
    else:
        print(json.dumps(final_output, indent=2))

if __name__ == "__main__":
    main()
