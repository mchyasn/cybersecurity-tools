#!/usr/bin/env python3
"""
ExploitChainAutomator – Post-Exploitation Chain Executor
"""

import argparse
import importlib.util
import json
import logging
import os
import subprocess
import sys
from pathlib import Path

import yaml

# Setup logging
os.makedirs("logs", exist_ok=True)
LOG_FILE = "logs/chain_execution.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, mode="w"),
        logging.StreamHandler(sys.stdout)
    ]
)

def load_config(path):
    if not os.path.isfile(path):
        logging.error(f"Config file not found: {path}")
        sys.exit(1)
    try:
        with open(path, "r") as f:
            return yaml.safe_load(f)
    except yaml.YAMLError as e:
        logging.error(f"Invalid YAML: {e}")
        sys.exit(1)

def detect_context():
    try:
        user = subprocess.check_output(["whoami"], text=True).strip()
        uid = subprocess.check_output(["id", "-u"], text=True).strip()
        logging.info(f"Current user: {user} (UID: {uid})")
        return {"user": user, "uid": uid}
    except Exception as e:
        logging.error(f"Context detection failed: {e}")
        return {"user": "unknown", "uid": "unknown"}

def load_module(module_name):
    try:
        module_path = Path(__file__).parent / "modules" / f"{module_name}.py"
        if not module_path.is_file():
            logging.error(f"Module file does not exist: {module_path}")
            return None
        spec = importlib.util.spec_from_file_location(module_name, str(module_path))
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module
    except Exception as e:
        logging.error(f"Module load failed: {e}")
        return None

def execute_chain(chain, interactive=False):
    results = []
    context = detect_context()
    for step in chain:
        module_name = step.get("module")
        params = step.get("params", {})
        logging.info(f"Executing module: {module_name} with params: {params}")

        if interactive:
            input(f"[+] Ready to run {module_name}. Press Enter to continue...")

        mod = load_module(module_name)
        if mod is None:
            results.append({"module": module_name, "error": "Module load failed"})
            continue

        try:
            output = mod.run(params)
            logging.info(f"{module_name} output: {output}")
            results.append({"module": module_name, "output": output})
        except Exception as e:
            logging.error(f"{module_name} execution failed: {e}")
            results.append({"module": module_name, "error": str(e)})

    return {"context": context, "chain_results": results}

def main():
    parser = argparse.ArgumentParser(
        description="ExploitChainAutomator – Post-Exploitation Chain Executor"
    )
    parser.add_argument(
        "-c", "--config",
        required=True,
        help="YAML config defining exploit chain"
    )
    parser.add_argument(
        "-o", "--output",
        default="scans/results.json",
        help="Output JSON file for results"
    )
    parser.add_argument(
        "-i", "--interactive",
        action="store_true",
        help="Prompt between chain stages"
    )
    args = parser.parse_args()

    config = load_config(args.config)
    chain = config.get("chain")
    if not chain:
        logging.error("No 'chain' defined in config.")
        sys.exit(1)

    results = execute_chain(chain, interactive=args.interactive)

    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    with open(args.output, "w") as f:
        json.dump(results, f, indent=2)

    logging.info(f"Chain execution complete. Results saved to {args.output}")

if __name__ == "__main__":
    main()
