#!/usr/bin/env python3
"""
ProtocolFuzzer – Network Protocol Vulnerability Fuzzer
"""

import argparse
import importlib.util
import json
import logging
import os
import sys
import yaml
import uuid
import datetime
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, TimeoutError

__version__ = "1.1.1"

# Logging
os.makedirs("logs", exist_ok=True)
LOG_FILE = "logs/fuzzer.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, mode="w"),
        logging.StreamHandler(sys.stdout)
    ]
)

def load_config(path):
    if not os.path.isfile(path):
        logging.error(f"Config not found: {path}")
        sys.exit(1)
    try:
        with open(path, "r") as f:
            config = yaml.safe_load(f)
        # Validate required keys and types
        required_keys = ["target", "port", "protocol"]
        for key in required_keys:
            if key not in config:
                logging.error(f"Missing required config key: {key}")
                sys.exit(1)
        if not isinstance(config["target"], str) or not isinstance(config["port"], int):
            logging.error("Invalid types in config: 'target' must be string, 'port' must be int")
            sys.exit(1)
        return config
    except yaml.YAMLError as e:
        logging.error(f"Invalid YAML: {e}")
        sys.exit(1)

def load_protocol_module(protocol_name):
    if not os.path.isdir("modules"):
        logging.error("Missing 'modules/' folder. Protocol modules cannot be loaded.")
        sys.exit(1)
    try:
        module_path = Path("modules") / f"{protocol_name.lower()}.py"
        if not module_path.is_file():
            logging.error(f"Protocol module not found: {module_path}")
            return None
        spec = importlib.util.spec_from_file_location(protocol_name, str(module_path))
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        if not hasattr(module, "fuzz") or not callable(module.fuzz):
            logging.error(f"Module {protocol_name} missing required fuzz() interface!")
            return None
        return module
    except Exception as e:
        logging.error(f"Module load failed: {e}")
        return None

def run_fuzz_with_timeout(module, config, max_timeout=60):
    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(module.fuzz, config)
        try:
            return future.result(timeout=max_timeout)
        except TimeoutError:
            logging.error(f"Fuzzing timed out for target {config.get('target')}:{config.get('port')}!")
            return {
                "error": "Timeout",
                "target": config.get("target"),
                "port": config.get("port")
            }

def main():
    parser = argparse.ArgumentParser(description="ProtocolFuzzer – Network Protocol Vulnerability Fuzzer")
    parser.add_argument("-c", "--config", required=True, help="Path to YAML config")
    parser.add_argument("-o", "--output", default="scans/results.json", help="Path to output JSON results")
    parser.add_argument("--test", action="store_true", help="Test loading of protocol module only")
    parser.add_argument("--version", action="store_true", help="Show version and exit")
    args = parser.parse_args()

    if args.version:
        print(f"ProtocolFuzzer v{__version__}")
        sys.exit(0)

    config = load_config(args.config)
    protocol = config.get("protocol")

    module = load_protocol_module(protocol)
    if module is None:
        logging.error("Failed to load protocol module.")
        sys.exit(1)

    if args.test:
        logging.info(f"Module {protocol} OK: has fuzz() interface")
        sys.exit(0)

    logging.info(f"Starting fuzz for protocol: {protocol}")

    results = run_fuzz_with_timeout(module, config)

    metadata = {
        "run_id": str(uuid.uuid4()),
        "timestamp": datetime.datetime.utcnow().isoformat() + "Z",
        "protocol": protocol,
        "target": config.get("target"),
        "port": config.get("port"),
        "version": __version__
    }

    final_output = {
        "metadata": metadata,
        "results": results
    }

    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    with open(args.output, "w") as f:
        json.dump(final_output, f, indent=2)

    logging.info(f"Fuzzing complete. Results saved to {args.output}")

if __name__ == "__main__":
    main()
